# Оценка сложности алгоритмов

Сложность - это зависимость числа итераций от входных данных

1. **y = 1**
    Константная сложность - независимо от того, какое количество входных данных будет, операция будет выполнена одна
    Например, задание размера массива, инициализация массива, сложение, умножение, деление
2. **y = log(n)**
    Логарифмическая сложность - зависимость количества выполнения операций от входных данных находится в логарифмической зависимости 
    Пример: бинарный поиск (массив на входе упорядоченный, массив делится пополам, сравнивается искомое значение с средним элементом массива, если искомое больше продолжаем алгоритм в правой части массива повторяя предыдущие пункты, то же произойдет если искомое меньше, смотрим в левом подмассиве)
    на каждой операции число операции в два раза меньше остается.
3. **y = n**
    Линейная сложность - зависимость количества операции зависит от количества входных данных по линейному закону.
    Пример: циклы, перебор данных
4. **y = n*log(n)**
    Линейно-логарифмическая сложность - объединение логарифмической и линейной сложности.
    Пример: быстрый алгоритм сортировки (пирамидальная сортировка, сортировка кучей (heapSort), quickSort).
    При больших входных значениях количество операций резко улетает вверх, но при малых значениях от нуля, она лучше чем линейная. Поэтому в разных библиотеках для оптимизации используются разные алгоритмы
5. **y = n^2**
    Квадратичная сложность  
    Пример: цикл внутри цикла
    Если мы берем алгоритм цикла в цикле и допустим у нас не одинаковое количество проходов в цикле то с точки зрения грубой оценки сложности принимаем большее число проходов в том или ином цикле 
6. **y = 2^n**
    Сложность 2 в степени n
    Пример: Есть два числа, нужно перебрать все возможные подмножества множества, состоящего из двух элементов
    1, 2 -> пустое множество, {1}, {2}, {1, 2} -> 2^2=4
    1,2,3 -> пустое, {1}, {2}, {3}, {1, 2}, {2, 3}, {1, 3}, {1, 2, 3} -> 2^3 =8
    Сначала она хуже, чем квадратичная,на следующем участке графика до какого-то момента она лучше, чем квадратичная, а затем сильно хуже, чем квадратичная
7. **y = n!**
    Эффективность нулевая. Сложность n фактриал. 
    Пример: сложно подобрать. Рекурсивное вычисление факториала - это НЕ факториальная сложность!


**Задача. Сокращение дробей:**
14/28 = 1/2
1. В школьном курсе алгоритм следующий: НОД(14, 28) = (2 * 7) / 2 * (2 * 7) -> 14
2. Наш вариант 1:
    1. Найдем минимальное из двух чисел
    2. В цикле пробегаемся от числа 2 (на 1 все итак делится) до наименьшего из двух чисел
    3. Затем проверка: если текущее итерируемое число разделилось без остатка на первое число и также на второе, то это и будет НОД
    Количество шагов: 13
    Сложность алгоритма: линейная
3. Наш вариант 2(улучшим прошлое значение):
    1. Найдем минимальное из двух чисел
    2. В цикле пробегаемся от нвименьшего из двух чисел до числа 1 
    3. Затем проверка: если текущее итерируемое число разделилось без остатка на первое число и также на второе, то это и будет НОД
    Количество шагов: 1
    Сложность алгоритма: линейная
    В данном случае, данный перебор выигрывает, но в случае, когда два числа не имеют НОД, количество шагов в двух этих алгоритмах совпадет 
4. Алгоритм Евклида:
    1. Берем два числа и вычистаем из большего меньшее
    2. как только числа сравнялись НОД найден
    Сложность алгоритма: меньше, чем линейная
    Количество шагов: 1
    Пример: 16 25
            16 9
            7  9
            7  2
            5  2
            3  2
            1  2
            1  1 НОД = 1
5. Ускоренный алгоритм Евклида(суть в нахождении остатков):
    1. Ищем остатки от деления большего числа на меньшее
    2. Переприсваиваем значение: в большее записываем меньшее(x=y), в меньшее остаток (y = x%y)
    3. повторяем те же действия до тех пор, пока второе число не будет равно 0
    4. В конце возвращаем переписанное значение первого числа (x)
    Сложность алгоритма: Ускоренный алгоритм Евклида наиболее оптимален
    Количество шагов: 1
    Пример: 35 28

Книги: 
1. Ахо Хопкрофт Ульман "Структуры данных и алгоритмы"
2. Александр Шень "Программирование: теоремы и задачи"
3. Роберт Сэджвик "Алгоритмы"
4. Дональд кнут "Искусство программирования" (лютое чтиво)
5. Грокаем алгоритмы неоч

