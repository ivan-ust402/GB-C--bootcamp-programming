# Оценка сложности алгоритмов

Сложность - это зависимость числа итераций от входных данных

1. y = 1
    Константная сложность - независимо от того, какое количество входных данных будет, операция будет выполнена одна
    Например, задание размера массива, инициализация массива, сложение, умножение, деление
2. y = log(n)
    Логарифмическая сложность - зависимость количества выполнения операций от входных данных находится в логарифмической зависимости 
    Пример, бинарный поиск (массив на входе упорядоченный, массив делится пополам, сравнивается искомое значение с средним элементом массива, если искомое больше продолжаем алгоритм в правой части массива повторяя предыдущие пункты, то же произойдет если искомое меньше, смотрим в левом подмассиве)
    на каждой операции число операции в два раза меньше остается.
3. y = n
    Линейная сложность - зависимость количества операции зависит от количества входных данных по линейному закону.
    Пример, циклы, перебор данных
4. y = n*log(n)
    Линейно-логарифмическая сложность - объединение логарифмической и линейной сложности.
    Пример, быстрый алгоритм сортировки (пирамидальная сортировка, сортировка кучей (heapSort), quickSort).
    При больших входных значениях количество операций резко улетает вверх, но при малых значениях от нуля, она лучше чем линейная. Поэтому в разных библиотеках для оптимизации используются разные алгоритмы
5. y = n^2
    Квадратичная сложность  
    Пример, цикл внутри цикла
    Если мы берем алгоритм цикла в цикле и допустим у нас не одинаковое количество проходов в цикле то с точки зрения грубой оценки сложности принимаем большее число проходов в том или ином цикле 
6. y = 2^n

7. y = n!
